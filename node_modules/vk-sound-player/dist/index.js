(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.myBundle = {})));
}(this, (function (exports) { 'use strict';

  class Widgets {
      query(dom) {
          var element = document.querySelector(dom);
          if (!element) {
              throw new Error('cannot find element ' + element);
          }
          return element;
      }
      // 生成一个随机的字符串
      uuid() {
          let s = [];
          let hexDigits = '0123456789abcdef';
          for (let i = 0; i < 36; i++) {
              s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
          }
          s[14] = '4'; // bits 12-15 of the time_hi_and_version field to 0010
          s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
          s[8] = s[13] = s[18] = s[23] = '-';
          let uuid = s.join('');
          return uuid;
      }
      // 时间转化方法
      formatTime(time) {
          let seconds = Math.round(time), minutes = Math.floor(time / 60);
          (minutes = minutes >= 10 ? minutes : '0' + minutes),
              (seconds = Math.floor(time % 60)),
              (seconds = seconds >= 10 ? seconds : '0' + seconds);
          return minutes + ':' + seconds;
      }
      // 合并对象方法
      merge(obj1, obj2) {
          let obj = Object.assign(obj1, obj2);
          return obj;
      }
      // 获取元素位置
      getPosition(node) {
          let left = node.offsetLeft; //获取元素相对于其父元素的left值let var left
          let top = node.offsetTop;
          let current = node.offsetParent; // 取得元素的offsetParent // 一直循环直到根元素
          while (current != null) {
              left += current.offsetLeft;
              top += current.offsetTop;
              current = current.offsetParent;
          }
          return {
              left: left,
              top: top
          };
      }
  }

  /// <reference path="../typings/audioTypes.d.ts" />
  /*
   * @class 音频播放
   * @params：
   */
  class AudioCore extends Widgets {
      constructor(options) {
          super();
          // 音频id, 避免重复创建多个音频
          this.id = '';
          // 音频链接地址
          this.url = '';
          // 音频对象
          this.audio = null;
          // 音频是否自动播放
          this.autoPlay = false;
          // 音频对象的总时长
          this.duration = '00:00';
          // 音频当前播放的时长
          this.currentTime = '00:00';
          // 进度条相关数据
          this.progressData = {};
          // 音量相关数据
          this.volumeData = {};
          // 缓存音频的音量
          this.volumeCache = 1;
          // 拖拽功能相关
          this.touchData = {
              initiated: false,
              startX: 0,
              left: 0
          };
          // 音量拖拽相关
          this.volumeTouch = {
              initiated: false,
              startX: 0,
              left: 0
          };
          // 进度条默认的样式
          this.progressStyle = {
              wrapper: {
                  width: '80%',
                  height: '0.1rem',
                  background: 'rgba(0,0,0,0.3)',
                  position: 'relative',
                  'border-radius': '100px'
              },
              cache: {
                  height: '100%',
                  width: '0',
                  position: 'absolute',
                  background: '#ccc',
                  top: 0,
                  left: 0,
                  margin: 0,
                  'border-radius': '100px'
              },
              current: {
                  height: '100%',
                  width: '0',
                  position: 'absolute',
                  background: '#ffcd32',
                  top: 0,
                  left: 0,
                  margin: 0,
                  'border-radius': '100px',
                  'z-index': 10
              },
              indicator: {
                  position: 'absolute',
                  width: '0.2rem',
                  height: '0.2rem',
                  ' border-radius': '50%',
                  background: '#fff',
                  right: '-0.05rem',
                  top: '-0.05rem'
              }
          };
          // 音频默认的样式
          this.volumeStyle = {
              current: {
                  width: '100%',
                  height: '0rem',
                  background: '#f00',
                  'border-radius': '1rem',
                  position: 'absolute',
                  bottom: 0,
                  left: 0,
                  'z-index': 10,
                  margin: 0
              },
              wrapper: {
                  width: '.1rem',
                  height: '1.4rem',
                  background: '#555',
                  'border-radius': '100px',
                  position: 'relative',
                  transform: 'rotate(180deg)'
              },
              indicator: {
                  position: 'absolute',
                  width: '0.2rem',
                  height: '0.2rem',
                  ' border-radius': '50%',
                  background: '#ccc',
                  right: '-0.05rem',
                  bottom: '-0.05rem',
                  'pointer-events': 'none'
              }
          };
          // 合并配置， 初始化音频
          Object.keys(options).forEach(key => (this[key] = options[key]));
          console.log(this.audioStatusChange);
          this.init();
      }
      /*
       *  @func: 初始化音频
       *  @return: void
       */
      init() {
          this.audio = new Audio();
          // 设置一个唯一表示id
          this.audio.id = this.uuid();
          this.audio.src = this.url;
          // this.audio.autoplay = this.autoPlay
          this.audio.volume = this.volumeCache;
          this.duration =
              this.audio.duration.toString() === 'NaN'
                  ? ''
                  : this.formatTime(this.audio.duration);
          // 初始化进度条， 音频调整
          this.initProgress();
          this.initVolume();
          // 初始化音频事件
          this.initEvent();
      }
      /**
       *  @func 初始化audio事件中心
       */
      initEvent() {
          let audio = this.audio, self = this;
          // Listen for audio errors
          audio.addEventListener('error', function (e) {
              self.errorEvent(e);
              self.errorFn && self.errorFn.apply(self, arguments);
          }, false);
          // loadedmetadata
          audio.addEventListener('loadedmetadata', function () {
              self.loadedmetadata && self.loadedmetadata.apply(self, arguments);
          }, false);
          // n
          audio.addEventListener('waiting', function () {
              self.waiting && self.waiting.apply(self, arguments);
          }, false);
          // Listen for audio canplay
          audio.addEventListener('canplay', function () {
              self.canplayEvent();
              //  用户自定义开发事件oncanplay，onloadedmetadata，onwaiting，onerror
              self.canplay && self.canplay.apply(self, arguments);
          }, false);
          // 音频改变时触发的事件
          audio.addEventListener('timeupdate', function () {
              // 更新进度条
              self.progressChange(2);
              // 更新音频播放时间
              self.currentTime = self.formatTime(self.audio.currentTime);
              self.timeUpdateFn && self.timeUpdateFn.apply(self, arguments);
          }, false);
          // 进度条开始缓存时触发的事件
          audio.addEventListener('progress', function () {
              self.progressChange(1);
              self.cacheFn && self.cacheFn.apply(self, arguments);
          }, false);
          // 音频播放结束后出发的方法
          audio.addEventListener('ended', function () {
              const { current } = self.progressData.refs;
              current.style.width = 0;
              self.currentTime = '00:00';
              self.endedFn && self.endedFn.apply(self, arguments);
          }, false);
      }
      /**
       * @func 切换音频播放状态
       * @param state: 是否播放;  callback 切换玩状态后的回调函数
       */
      togglePlay(state) {
          state ? this.audio.play() : this.audio.pause();
          // 执行用户传入的回调函数
          this.audioStatusChange();
      }
      /**
       * @func 实时更新进度条
       * @param element: dom元素， type：1 音频进度条， 2 缓存进度条
       *
       */
      progressChange(type) {
          if (!(!this.audio.progressReady &&
              this.progressData.showProgress &&
              this.progressData.parent)) {
              return;
          }
          let audio = this.audio, wrapperWidth = this.progressData.refs.wrapper.clientWidth, { current, cache } = this.progressData.refs;
          // 缓存进度条
          if (type === 1) {
              let timeRanges = audio.buffered, timeBuffered = timeRanges.length > 0 ? timeRanges.end(timeRanges.length - 1) : 0;
              // if(timeRanges && timeBuffered >= 0) { return }
              cache.style.width = wrapperWidth * (timeBuffered / audio.duration) + 'px';
              return;
          }
          current.style.width =
              wrapperWidth * (audio.currentTime / audio.duration) + 'px';
      }
      /*
       * 初始化音频的进度条
       */
      initProgress() {
          if (!this.audio.progressReady &&
              this.progressData.showProgress &&
              this.progressData.parent) {
              this.createProgress();
              return;
          }
      }
      // 创建进度条
      createProgress() {
          let domText = `<div class="progress-wrapper"><p class="cache"></p> <p class="current">
                        <span class="indicator"></span></p></div>`, self = this;
          this.query(this.progressData.parent).innerHTML = domText;
          // 存储Dom结构
          this.progressData.refs = {
              wrapper: this.query('.progress-wrapper'),
              cache: this.query('.cache'),
              current: this.query('.current'),
              indicator: this.query('.indicator')
          };
          // 添加样式
          Object.keys(this.progressData.refs).forEach(key => {
              this.setStyle(this.progressData.refs[key], this.progressStyle[key]);
              // 合并传入的样式
              if (this.progressData.style && this.progressData.style[key]) {
                  this.setStyle(this.progressData.refs[key], this.progressData.style[key]);
              }
          });
          const { wrapper } = this.progressData.refs;
          wrapper.addEventListener('click', self.progressClick.bind(this));
      }
      // 进度条点击功能， 直接更新进度
      progressClick(event) {
          const { wrapper, label, current, indicator } = this.progressData.refs;
          let target = event.srcElement || event.target;
          if (target === indicator) {
              return;
          }
          let offsetWidth = Math.min(wrapper.clientWidth, Math.max(0, event.offsetX));
          current.style.width = offsetWidth + 'px';
          // 同步audio的进度
          this.audio.currentTime =
              this.audio.duration * (current.clientWidth / wrapper.clientWidth);
      }
      // 初始化音频播放
      initVolume() {
          if (!this.audio.volumeReady &&
              this.volumeData.showVolume &&
              this.volumeData.parent) {
              this.createVolume();
              return;
          }
      }
      // 创建音量条
      createVolume() {
          let htmlText = `<div class="volumn-wrapper"> <p class="current-volumn"><span class="volumn-indicator"></span></p>
                        </div>`, self = this;
          this.query(this.volumeData.parent).innerHTML = htmlText;
          // 如果用户传入了label
          if (this.volumeData.label) {
              this.volumeData.labelDom = this.query(this.volumeData.label);
          }
          // 存储Dom结构
          this.volumeData.refs = {
              wrapper: this.query('.volumn-wrapper'),
              current: this.query('.current-volumn'),
              indicator: this.query('.volumn-indicator')
          };
          // 添加样式
          Object.keys(this.volumeData.refs).forEach(key => {
              this.setStyle(this.volumeData.refs[key], this.volumeStyle[key]);
              // 合并传入的样式
              if (this.volumeData.style && this.volumeData.style[key]) {
                  this.setStyle(this.volumeData.refs[key], this.volumeData.style[key]);
              }
          });
          // 判断音频进度条方向
          this.volumeData.direction =
              this.volumeData.refs.wrapper.clientHeight >
                  this.volumeData.refs.wrapper.clientWidth
                  ? 'vertical'
                  : 'horizontal';
          // 添加事件
          const { wrapper, current } = this.volumeData.refs;
          if (this.volumeData.direction === 'vertical') {
              current.style.height = wrapper.clientHeight * (this.volumeCache / 1);
          }
          else {
              current.style.width = wrapper.clientWidth * (this.volumeCache / 1);
          }
          wrapper.addEventListener('click', self.volumeChange.bind(this));
          this.volumeData.labelDom &&
              this.volumeData.labelDom.addEventListener('click', self.volumeStatusChange.bind(this));
      }
      // 点击音频条触发的事件
      volumeChange(event) {
          const { wrapper, label, current } = this.volumeData.refs;
          let offset = 0;
          if (this.volumeData.direction === 'vertical') {
              offset = Math.min(wrapper.clientHeight, Math.max(0, event.offsetY));
              current.style.height = offset + 'px';
              // 同步audio的音量
              this.volumeCache = this.audio.volume =
                  current.clientHeight / wrapper.clientHeight;
          }
          else {
              offset = Math.min(wrapper.clientWidth, Math.max(0, event.offsetX));
              current.style.width = offset + 'px';
              // 同步audio的音量
              this.volumeCache = this.audio.volume =
                  current.clientWidth / wrapper.clientWidth;
          }
      }
      // 点击音频的label改变音频是否静音的状态
      volumeStatusChange() {
          const { wrapper, label, current } = this.volumeData.refs;
          // 还原之前的状态
          if (this.volumeData.direction === 'vertical') {
              if (parseFloat(this.audio.volume) === 0) {
                  current.style.height =
                      wrapper.clientHeight * (this.volumeCache / 1) + 'px';
                  return;
              }
              this.audio.volume = 0;
              current.style.height = 0;
          }
          else {
              if (parseFloat(this.audio.volume) === 0) {
                  this.audio.volume = this.volumeCache;
                  current.style.width =
                      wrapper.clientWidth * (this.volumeCache / 1) + 'px';
                  return;
              }
              this.audio.volume = 0;
              current.style.width = 0;
          }
      }
      // 添加样式
      setStyle(element, style) {
          let styles = element.getAttribute('style')
              ? element.getAttribute('style')
              : '';
          Object.keys(style).forEach(function (key) {
              styles += key + ':' + style[key] + ';';
              element.setAttribute('style', styles);
          });
      }
      // 音频播放出错时， 出发的方法
      errorEvent(event) {
          // console.error(`audio error: ${event} :  audio error:  ${this.audio.error}`)
          // console.error(this.audio.error)
          this.errorFn && this.errorFn.apply(this, arguments);
      }
      // 音频可以播放时，触发的事件
      canplayEvent() {
          this.duration = this.formatTime(this.audio.duration);
          // 如果设置了自动播放， 那么自动播放音频
          if (this.autoPlay) {
              this.togglePlay(true);
          }
      }
      // 刷新音频操作
      refresh() {
          this.query(this.progressData.parent).innerHTML = '';
          this.audio.src = null;
          this.initProgress();
          this.initEvent();
      }
  }
  // mixin模式混入

  class AudioModelPc extends AudioCore {
      constructor(options) {
          super(options);
          this.initAudioPcProgress();
          this.initAudioPcVolume();
      }
      initAudioPcVolume() {
          if (!this.volumeData.showVolume || !this.volumeData.parent) {
              return;
          }
          const { wrapper } = this.volumeData.refs;
          let self = this;
          // 音量条添加相应的事件
          wrapper.addEventListener('mousedown', self.volumeMouseDown.bind(self));
          wrapper.addEventListener('mousemove', self.volumeMouseMove.bind(self));
          wrapper.addEventListener('mouseup', self.volumeMouseUp.bind(self));
          wrapper.addEventListener('mouseleave', self.volumeMouseUp.bind(self));
      }
      volumeMouseDown(event) {
          const { current, wrapper } = this.volumeData.refs;
          this.volumeTouch = {
              initiated: true,
              startX: this.volumeData.direction === 'vertical'
                  ? this.getPosition(wrapper).top
                  : this.getPosition(wrapper).left,
              left: current.clientWidth
          };
      }
      volumeMouseMove(event) {
          let { wrapper, current, indicator } = this.volumeData.refs;
          if (!this.volumeTouch.initiated) {
              return;
          }
          let offset = 0;
          // console.log(this.volumeData.direction === 'vertical')
          if (this.volumeData.direction === 'vertical') {
              offset = Math.min(wrapper.clientHeight, Math.max(0, event.offsetY));
              current.style.height = offset + 'px';
              // 同步audio的音量
              this.volumeCache = this.audio.volume =
                  current.clientHeight / wrapper.clientHeight;
          }
          else {
              offset = Math.min(wrapper.clientWidth, Math.max(0, event.clientX - this.volumeTouch.startX));
              // 更新音频的播放时间
              current.style.width = offset + 'px';
              // 同步audio的音量
              this.volumeCache = this.audio.volume =
                  current.clientWidth / wrapper.clientWidth;
          }
      }
      volumeMouseUp() {
          let { wrapper, current } = this.volumeData.refs;
          this.volumeTouch.initiated = false;
      }
      // 初始化pc端播放单元
      initAudioPcProgress() {
          if (!(!this.audio.progressReady &&
              this.progressData.showProgress &&
              this.progressData.parent)) {
              return;
          }
          const { wrapper, indicator } = this.progressData.refs;
          let self = this;
          // 进度条添加相应的事件
          wrapper.addEventListener('mousedown', self.progressMouseDown.bind(self));
          wrapper.addEventListener('mousemove', self.progressMouseMove.bind(self));
          wrapper.addEventListener('mouseup', self.progressMouseUp.bind(self));
          wrapper.addEventListener('mouseleave', self.progressMouseUp.bind(self));
      }
      progressMouseDown(event) {
          const { current, wrapper } = this.progressData.refs;
          this.touchData = {
              initiated: true,
              startX: this.getPosition(wrapper).left,
              left: current.clientWidth
          };
          this.togglePlay(false);
      }
      progressMouseMove(event) {
          let { wrapper, current, indicator } = this.progressData.refs;
          if (!this.touchData.initiated) {
              return;
          }
          let offsetWidth = Math.min(wrapper.clientWidth, Math.max(0, event.clientX - this.touchData.startX));
          // 更新音频的播放时间
          current.style.width = offsetWidth + 'px';
      }
      progressMouseUp() {
          let { wrapper, current } = this.progressData.refs;
          if (this.touchData.initiated) {
              this.touchData.initiated = false;
              this.audio.currentTime =
                  this.audio.duration * (current.clientWidth / wrapper.clientWidth);
              if (this.audio.paused) {
                  this.togglePlay(true);
              }
          }
      }
      refreshInstance() {
          this.refresh();
          this.initAudioPcProgress();
      }
  }
  // ts里面super具体的作用

  class AudioModelMobile extends AudioCore {
      constructor(options) {
          super(options);
          this.initAudioMobile();
      }
      // 初始化pc端播放单元
      initAudioMobile() {
          if (!(!this.audio.progressReady &&
              this.progressData.showProgress &&
              this.progressData.parent)) {
              return;
          }
          const { wrapper, indicator } = this.progressData.refs;
          let self = this;
          // 进度条添加相应的事件
          indicator.addEventListener('touchstart', self.progressTouchStart.bind(this));
          indicator.addEventListener('touchmove', self.progressTouchMove.bind(this));
          indicator.addEventListener('touchend', self.progressTouchEnd.bind(this));
      }
      progressTouchStart(e) {
          const { current, wrapper } = this.progressData.refs;
          this.touchData = {
              initiated: true,
              startX: e.touches[0].pageX,
              left: current.clientWidth
          };
          // 暂停音频， 拖拽结束后在播放
          this.togglePlay(false);
      }
      progressTouchMove(e) {
          let { wrapper, current } = this.progressData.refs;
          e.preventDefault();
          if (!this.touchData.initiated) {
              return;
          }
          let deltaX = e.touches[0].pageX - this.touchData.startX;
          let offsetWidth = Math.min(wrapper.clientWidth, Math.max(0, this.touchData.left + deltaX));
          // 更新音频的播放时间
          current.style.width = offsetWidth + 'px';
      }
      progressTouchEnd() {
          let { wrapper, current } = this.progressData.refs;
          this.touchData.initiated = false;
          this.audio.currentTime =
              this.audio.duration * (current.clientWidth / wrapper.clientWidth);
          if (this.audio.paused) {
              this.togglePlay(true);
          }
      }
  }

  const renderAudio = (options) => {
      // 如果是移动端， 那么实力话移动端的audioModel
      let reg = /Android|webOS|iPhone|iPod|BlackBerry|iPad/i;
      if (reg.test(navigator.userAgent)) {
          return new AudioModelMobile(options);
      }
      return new AudioModelPc(options);
  };

  exports.AudioModelPc = AudioModelPc;
  exports.AudioModelMobile = AudioModelMobile;
  exports.renderAudio = renderAudio;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
