"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AudioCore_1 = require("../../core/AudioCore");
class AudioModelMobile extends AudioCore_1.AudioCore {
    constructor(options) {
        super(options);
        this.initAudioMobile();
    }
    // 初始化pc端播放单元
    initAudioMobile() {
        if (!(!this.audio.progressReady &&
            this.progressData.showProgress &&
            this.progressData.parent)) {
            return;
        }
        const { wrapper, indicator } = this.progressData.refs;
        let self = this;
        // 进度条添加相应的事件
        indicator.addEventListener('touchstart', self.progressTouchStart.bind(this));
        indicator.addEventListener('touchmove', self.progressTouchMove.bind(this));
        indicator.addEventListener('touchend', self.progressTouchEnd.bind(this));
    }
    progressTouchStart(e) {
        const { current, wrapper } = this.progressData.refs;
        this.touchData = {
            initiated: true,
            startX: e.touches[0].pageX,
            left: current.clientWidth
        };
        // 暂停音频， 拖拽结束后在播放
        this.togglePlay(false);
    }
    progressTouchMove(e) {
        let { wrapper, current } = this.progressData.refs;
        e.preventDefault();
        if (!this.touchData.initiated) {
            return;
        }
        let deltaX = e.touches[0].pageX - this.touchData.startX;
        let offsetWidth = Math.min(wrapper.clientWidth, Math.max(0, this.touchData.left + deltaX));
        // 更新音频的播放时间
        current.style.width = offsetWidth + 'px';
    }
    progressTouchEnd() {
        let { wrapper, current } = this.progressData.refs;
        this.touchData.initiated = false;
        this.audio.currentTime =
            this.audio.duration * (current.clientWidth / wrapper.clientWidth);
        if (this.audio.paused) {
            this.togglePlay(true);
        }
    }
}
exports.AudioModelMobile = AudioModelMobile;
//# sourceMappingURL=index.js.map