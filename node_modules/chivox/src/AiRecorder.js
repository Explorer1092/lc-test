/*
 * ChiVox API provides ChiVox Ltd's (www.chivox.com) world leading pronunciation
 * evaluation, speech recognition technologies, and text-to-speech technologies.  *
 * ChiVox Ltd opens this API hoping make every programmer be capable to implement
 * speech enabled applicaitons.
 *
 * Copyright (c) 2008-2018 by ChiVox. All rights reserved.
 *
 */
/**
 * Flash录音机<br>
 * 状态码的详细信息，参见chivox.AiStatusCode <br>
 * Updated by kai.li, at 2017-04-05.
 * $Id: AiRecorder.js 4935 2014-08-21 09:03:38Z zhiyuan.liang $
 *
 * 使用方法：<br>
 * new chivox.AiRecorderAs(options)<br>
 * options.id {string} 录音机id，对应html页面节点的id。默认为"aiRecorder"<br>
 * options.width {int} flashRecorder 宽度，默认为220<br>
 * options.height {int} flashRecorder 高度，默认为140<br>
 * options.wmode {string} flash模式，linux下默认为"Window", 否则默认为"Opaque"，可选值为"Window", "Opaque", "Transparent"<br>
 * options.showFlash {boolean} 是否显示Flash。默认为true<br>
 * options.appKey {string} 语音服务器appKey。该字段必须设置。<br>
 * options.secretKey {string} 语音服务器secretKey。该字段必须设置。<br>
 * options.onFlashLoad {function} flash加载完成的回调，回调参数(code, message)。可能的code值有："50000"<br>
 * options.onConnectorStatusChange {function} flash录音机连接服务器回调，回调参数(code, message)。可能的code值有："50100", "50103", "50104", "50109"<br>
 * options.onMicStatusChange {function} 麦克风检测回调，回调参数(code, message)。可能的code值有："50001", "50002", "50003", "50007"<br>
 * options.onError {function} 出错回调，回调参数(code, message)。可能的code值有："50201", "50104"<br>
 * options.coreTimeout {int} 内核评分超时时间，单位ms。默认为5000，取值范围[1000,40000]<br>
 * options.logLevel {string} flash日志级别，默认值为"DEBUG"，可选值为"DEBUG" "INFO" "WARN" "ERROR"<br>
 * options.logTarget {string} flash日志目标，默认值为"1"，可选值为"1","2","3"<br>
 * 1: 同时对Arthropod 和js 输出log信息，Arthropod 的输出信息级别由logLevel 来指定<br>
 * 2: 只输出Arthropod 的信息，Arthropod 的输出信息级别由logLevel 来指定<br>
 * 3: 只输出Arthropod 的 ERROR 级别以上包括这个级别的 log 信息<br>
 *
 * 示例：<br>
 * var recorder = new chivox.AiRecorderAs({
 * <br>
 *     id: "aiRecorder", <br>
 *     appKey: "1298426941825", <br>
 *     secretKey: "595fd7706b9a96bd892a0c88a2e772b0d0565316", <br>
 *     userId: "guest", <br>
 *     onFlashLoad: function(code, message){
 *     }, <br>
 *     onConnectorStatusChange: function(code, message){
 *     }, <br>
 *     onMicStatusChange: function(code, message){
 *     }, <br>
 *     onError: function(code, message){
 *     }
 * <br>
 * });
 *
 * @class chivox的Flash录音机
 */
import cookie from "cookies-js";
import recordMedia from "../assert/sound/ding.mp3";
chivox.AiRecorder = (function() {
  var TIME_OUT = 3600;
  var SERVER="cloud.chivox.com";

  chivox.AiRecorderAs = function(options){
    /**
     * 是否可以录音
     */
    this.canRecord = false;
    this.loaded = false;

    /**
     * 默认参数
     * @ignore
     */
    this.params = {
        /**
         * 录音机id，对应html页面节点的id。默认为"aiRecorder"
         * @ignore
         */
        id: "aiRecorder",

        /**
         * flashRecorder地址
         * @ignore
         */
        flashRecorderUrl: chivox.host + "/Resources/swf/AudioRecorder4JS_v3.3.2.swf",
        //flashRecorderUrl: chivox.host + "/Resources/swf/AudioRecorder4JS_v3.2.13.swf",

        /**
         * expressInstall地址
         * @ignore
         */
        expressInstallUrl: chivox.host + "/Resources/swf/expressInstall.swf",

        /**
         * 是否缓存Flash
         * @ignore
         */
        isCache: true,

        /**
         * flashRecorder 宽度310 | 220
         * @ignore
         */
        width: 220,

        /**
         * flashRecorder 高度200 | 140
         * @ignore
         */
        height: 140,

        /**
         * flash模式，可选值为"Window", "Opaque", "Transparent"
         * @ignore
         */
        wmode: "Opaque",

        /**
         * 背景色
         * @ignore
         */
        backgroundColor: "0x00ffffff",

        /**
         * 是否显示Flash。默认为true
         * @ignore
         */
        showFlash: true,

        /**
         * 语音服务器appKey
         * @ignore
         */
        appKey: "",

        /**
         * 语音服务器地址。默认ws://cloud.chivox.com
         * @ignore
         */
         server: "ws://cloud.chivox.com",

        /**
         * 语音备份服务器back_server, 连接失败时会再次连接back_server, 默认wss://cloud.chivox.com 
         * @ignore
         */
        back_server: null,

        /**
         * 用户id
         * @ignore
         */
        userId: "jsssdk-guset-user",

        /**
         *  flash加载完成的回调，回调参数(code, message)
         * @ignore
         */
        onFlashLoad: "",

        /**
         * flash录音机连接服务器回调，回调参数(code, message)
         * @ignore
         *
         */
        onConnectorStatusChange: "",

        /**
         * 麦克风检测回调，回调参数(code, message)
         * @ignore
         */
        onMicStatusChange: "",

        /**
         * 出错回调，回调参数(code, message)
         * @ignore
         */
        onError: "",

        /**
         * 内核评分超时时间，单位ms。默认为60000
         * @ignore
         */
        coreTimeout: 60000,

        /**
         * flash日志级别，默认值为"DEBUG"，可选值为"DEBUG" "INFO" "WARN" "ERROR"
         * @ignore
         */
        logLevel: "DEBUG",

        /**
         * flash日志目标，默认值为"1"，可选值为"1","2","3"<br>
         * 1: 同时对Arthropod 和js 输出log信息，Arthropod 的输出信息级别由logLevel 来指定<br>
         * 2: 只输出Arthropod 的信息，Arthropod 的输出信息级别由logLevel 来指定<br>
         * 3: 只输出Arthropod 的 ERROR 级别以上包括这个级别的 log 信息
         * @ignore
         */
        logTarget: "1",

        /**
         * 提示面板的语言，可选值有"en_US"、"zh-CN"(默认)
         * @ignore
         */
        language: "zh-CN"
    };
    /**
     * @ignore
     */
    this.__extend(this.params, options);
    if (navigator.platform.match(/inux/g) == "inux") {
        this.params.wmode = "Window";
    }

    if (typeof jsReady == "undefined") {
        /**
         * @ignore
         */
        window.jsReady = false;
        /**
         * @ignore
         */
        window.jsIsReady = function(){
            return true;
            //return jsReady;
        }
        //window.onload = function(){
        //    jsReady = true;
        //}
    }
    /**
     * @ignore
     */
    this.aiDebug = new chivox.AiDebug();

    /**
     * 返回的录音id数组
     * @ignore
     */
    this.recordIdArr = [];

    /**
     * 评分结果缓存
     * @ignore
     */
    this.result = {};

    /**
     * 获得评分的延时计时器
     * @ignore
     */
    this.__getScoreTimeoutId = [];
    /**
     * 最后一次评分的开始时间
     */
    this.__getScoreTimeoutStartTime = 0;

    /**
     * 当前的视图
     * @ignore
     */
    this.currentView = {
        meter: {
            x: 0,
            y: -25,
            visible: true
        },
        slider: {
            x: 0,
            y: 20,
            visible: true
        },
        viewer: {
            x: 0,
            y: 0,
            visible: false
        }
    };

    /**
     * 空白视图
     * @ignore
     */
    this.noView = {
        meter: {
            x: 0,
            y: -25,
            visible: false
        },
        slider: {
            x: 0,
            y: 20,
            visible: false
        },
        viewer: {
            x: 0,
            y: 0,
            visible: false
        }
    };

/**
     * 回调缓存
     * @ignore
     */
    chivox.AiRecorderAs.cache = chivox.AiRecorderAs.cache || {};

    ///**
    // * 录音参数缓存
    // * @ignore
    // */
    //chivox.AiRecorderAs.paramsCache = chivox.AiRecorderAs.paramsCache || {};

    var x = this;

    /**
     * 录音方法回调序列
     * RECORD_INIT, RECORD_CMD_START, RECORD_CMD_STOP, RECORD_ACT_START, RECORD_ACT_STOP
     * @ignore
     */
    x.__recordOrderState = "RECORD_INIT";
    /**
     * 回放方法回调序列
     * REPLAY_INIT, REPLAY_CMD_START, REPLAY_CMD_STOP, REPLAY_ACT_START, REPLAY_ACT_STOP
     * @ignore
     */
    x.__replayOrderState = "REPLAY_INIT";

    /**
     * @ignore
     */
    x.canRecordCheck = {
        flashLoaded: false,
        serverConnected: false,
        micAllowed: false,
        /**
         * @ignore
         */
        refresh: function(){
            if (x.canRecordCheck.flashLoaded && x.canRecordCheck.serverConnected && x.canRecordCheck.micAllowed) {
                x.canRecord = true;
            } else {
                x.canRecord = false;
            }
        }
    };

    /**
     * @ignore
     * @param {string} text
     */
    function decodeMessage(text){
        if (typeof text == "string") {
            text = text.replace(/%22/g, "\"").replace(/%5c/g, "\\").replace(/%26/g, "&").replace(/%25/g, "%");
        }
        return text;
    }

    chivox.AiRecorderAs.cache[x.params.id + "OnLog"] = function(message) {
      console.debug(message);
    }




    var _init =function() {
      audioRecorderFlashVars.timestamp = this.params.timestamp;
      audioRecorderFlashVars.sig = this.params.sig;

      if (navigator.platform.match(/inux/g) == "inux") {
          var FO = {
              movie: x.params.flashRecorderUrl,
              width: x.params.width,
              height: x.params.height,
              majorversion: "10",
              build: "0",
              id: x.params.id + "UFO",
              name: x.params.id + "UFO",
              wmode: x.params.wmode,
              allowscriptaccess: "always",
              flashvars: mf.param(audioRecorderFlashVars)
          };
          UFO.create(FO, x.params.id);

      } else {
          // dynamically insert flash audio recorder
          var audioRecorderParams = {
              allowScriptAccess: "always",
              wmode: x.params.wmode
              //bgcolor: "#ffff00"
          };
          var audioRecorderAttributes = {
              id: x.params.id,
              name: x.params.id,
              wmode: x.params.wmode
              //bgcolor: "#ffff00"
          };

          for(var k in audioRecorderFlashVars) {
              if(typeof audioRecorderFlashVars[k] === "undefined") {delete audioRecorderFlashVars[k];}
          }
          swfobject.embedSWF(x.params.flashRecorderUrl, x.params.id, x.params.width, x.params.height, "10.0.0", x.params.expressInstallUrl, audioRecorderFlashVars, audioRecorderParams, audioRecorderAttributes, function(s) {
            console.info('[ embedSWF ]:', s);
            
          }); 
          ai$("#" + x.params.id).addClass("loading");
      console.info('[ _init ]: here', x.params.id, audioRecorderFlashVars);
      }
   }

  if (this.params.hasOwnProperty("sig") && this.params.hasOwnProperty("timestamp")) {
    _init();
  } else {
    this.getSig(_init, audioRecorderFlashVars);
  }
}


/**
 * 扩展对象
 */
chivox.AiRecorderAs.prototype.__extend = function(o, o1){
    if (Object.prototype.toString.call(o) === "[object Object]" && Object.prototype.toString.call(o1) === "[object Object]") {//isObject
        for (var key in o1) {
            if(o1.hasOwnProperty(key) == false){
                continue;
            }
            o[key] = o1[key];
        }
    }
}









/**
 * 录音完成后获取用户得分，直到取得得分为止才执行回调
 *
 * @param {object} options 评分参数<br>
 *   options.recordId {undefined || string || array} 需要获得评分的recordId<br>
 *   options.success {function} 评分成功后调用该函数<br>
 *   options.error {function} 评分失败后调用该函数（不可用）
 */
chivox.AiRecorderAs.prototype.getScores = function(options){
    var x = this;
    //if (x.__getScoreTimeoutId != null) {
    //    window.clearTimeout(x.__getScoreTimeoutId);
    //    x.__getScoreTimeoutId = null;
    //    x.aiDebug.debug("==== getScores clearTimeout ====");
    //}
    //x.aiDebug.debug("==== getScores start ====");
    x.__getScoreTimeoutStartTime = new Date().getTime();
    x.__getScores(options);
}

chivox.AiRecorderAs.prototype.__getScores = function(options){
    var x = this;
    var tokenId = options.recordId;

    if (typeof tokenId === "undefined" || tokenId === null || tokenId === "") {
        if (typeof options.success == "function") {
            options.success(x.result);
            x.aiDebug.debug("==== getScores end ====");
        }

    } else if (typeof tokenId == "string") {//isString
        if (typeof x.result[tokenId] != "undefined") {
            var result = {};
            result[tokenId] = x.result[tokenId];
            if (typeof options.success == "function") {
                options.success(result);
                x.aiDebug.debug("==== getScores end ====");
            }

        } else {
            if (new Date().getTime() - x.__getScoreTimeoutStartTime >= x.params.coreTimeout) {
                x.result[tokenId] = {
                    recordId: tokenId,
                    result: {
                        errID: "50201",
                        error: {
                            tip: "JSSDK getScore timeout"
                        }
                    }
                };
            }
            (function(x, options){
                x.__getScoreTimeoutId.push(window.setTimeout(function(){
                    x.__getScores(options);
                }, 200));
            })(x, options);
        }

    } else if (Object.prototype.toString.call(tokenId) === "[object Array]") {// isArray
        var result = {};
        var hasAllResult = true;
        for (var i in tokenId) {
            if(tokenId.hasOwnProperty(i) == false){
                continue;
            }
            var key = tokenId[i];
            if (typeof x.result[key] != "undefined") {
                result[key] = x.result[key];

            } else {
                if (new Date().getTime() - x.__getScoreTimeoutStartTime < x.params.coreTimeout) {
                    hasAllResult = false;
                    (function(x, options){
                        x.__getScoreTimeoutId.push(window.setTimeout(function(){
                            x.__getScores(options);
                        }, 200));
                    })(x, options);
                } else {
                    hasAllResult = true;
                    for (var n in tokenId) {
                        if(tokenId.hasOwnProperty(n) == false){
                            continue;
                        }
                        var key = tokenId[n];
                        if (typeof x.result[key] == "undefined") {
                            x.result[key] = {
                                recordId: key,
                                result: {
                                    errID: "50201",
                                    error: {
                                        tip: "JSSDK getScore timeout"
                                    }
                                }
                            };
                            result[key] = x.result[key];
                        }
                    }
                }
                break;
            }
        }
        if (hasAllResult) {
            if (typeof options.success == "function") {
                options.success(result);
                x.aiDebug.debug("==== getScores end ====");
            }
        }
    }
}

  var AiRecorderH5 = function (options) {
        var Ai = this;
        var WORKER_VAD_PATH = chivox.host + "/Classes/H5/audio/vad.js";
        var WORKER_RECORDER_PATH = chivox.host + '/Classes/H5/audio/recorderWorker.js';

        var LOGSERVER = "//log.cloud.chivox.com/bus";

        this.dictResults = {};
        this.__onStopReplay = null;
        this.__durationTimer = null;

        this.params = {
            id: "aiRecorder",
            appKey: "",
            alg: "sha1",
            sigurl: "",
            userId: "",
            encode: "raw", //编码类型，raw：不压缩， speex：speex压缩
            server: document.location.protocol == "https:" ? "wss://" + SERVER : "ws://" + SERVER,
            //语音服务地址
            coreTimeout: 10000, //评分超时
            onStartReplay: function () {
            },
            onStopReplay: function () {
              if(typeof Ai.__onStopReplay == 'function') {
                Ai.__onStopReplay();
              }
            },
            onGetResult: function (result) {
              //console.info(result);
            },
            onError: function (error) {
              console.error(error);
            },
            onVolume: function () {
            },
            onFlashLoad: function(code, message){//兼容AS//Flash加载完成的回调，其他所有与录音机的操作必须在这个回调之后进行。//code值有：50000
                console.log(code);
            },
            onConnectorStatusChange: function(code, message){//兼容AS
                //连接器状态发生改变时回调
                //code值有：50100, 50103, 50104, 50109
            },
            onMicStatusChange: function(code, message){//兼容AS
                //麦克风状态发生改变时回调。第一次加载Flash时也会触发该回调
                //code值有：50001, 50002, 50003
            },
            onRecordIdGenerated: function(code, message) {},
            onStart: function(code, message) {},
            onStop: function(code, message) {},
            onInternalScore: function(code, message) {}
        };

        this.showVolumeBar = function() {};

        var _check = function(condition, error) {
          var ok = condition; 

          if (!ok) {
            console.error(error);
            if (typeof options['onError'] != "undefined")
              options["onError"](error);
          }

          return ok;
        }

        navigator.getMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

        if (!_check((document.location.protocol == "https:"), "[ AiRecorderH5 ]ERROR: 当前页面使用的不是https协议，HTML5模式只能在HTTPS协议下使用。")) return;
        if (!_check(window.WebSocket, "[ AiRecorderH5 ]ERROR: 浏览器不支持websocket.")) return;
        if (!_check(window.Worker, "[ AiRecorderH5 ]ERROR: 浏览器不支持Worker.")) return;
        if (!_check(navigator.getMedia, "[ AiRecorderH5 ]ERROR: 浏览器不支持录音.")) return;

        if (options['server'] && !(options['server'].substr(0, 3) == "wss")) {
          console.warn("[ AiRecorderH5 ]ERROR: HTML5模式只能连接WSS协议，当前server(" + options['server'] + ")不可用，使用默认server地址：" + Ai.params.server);
          delete options['server'];
        }


        this.vad_worker = null; //new Worker(WORKER_VAD_PATH);
        this.record_worker = null; // new Worker(WORKER_RECORDER_PATH);
        this.compress = null; //new Worker(WORKER_SPEEX_PATH);

        ai$.get(WORKER_VAD_PATH, function(vad_js) {
          Ai.vad_worker = new Worker(window.URL.createObjectURL(new Blob([vad_js])));
        }).done(function() {
            ai$.get(WORKER_RECORDER_PATH, function(recorder_js) {
              Ai.record_worker = new Worker(window.URL.createObjectURL(new Blob([recorder_js])));
          }).done(function() {
            console.debug("[ AiRecorderH5 ]: record worker started.");

            if (Ai.params['encode'] != "raw") {
                var WORKER_SPEEX_PATH = chivox.host + "/Classes/H5/audio/speex.js";
                ai$.get(WORKER_SPEEX_PATH, function(speex_js) {
                    Ai.compress = new Worker(window.URL.createObjectURL(new Blob([speex_js])));
                    Ai.engine=new Engine(Ai);
                    console.debug("[ AiRecorderH5 ]: speex worker started.");
                }).fail(function(xhr3, result3) {
                  console.error("[ AiRecorderH5 ]: speex worker start failed from url: " + WORKER_SPEEX_PATH, 'status:', result3);
                });
            } else {
              Ai.engine=new Engine(Ai);
            }
          }).fail(function(xhr2, result2) {
            console.error("[ AiRecorderH5 ]: record worker start failed from url: " + WORKER_RECORDER_PATH, 'status:', result2);
          });
        }).fail(function(xhr, result) { 
            console.error("[ AiRecorderH5 ]: vad worker start failed from url: " + WORKER_VAD_PATH, 'status:', result);
        });

        this.canRecord = false;

        if (typeof options != "undefined") {
            for (var i in options) {
                if (Ai.params.hasOwnProperty(i)) {
                    Ai.params[i] = options[i];
                } else {
                    //console.debug("AiEngine: unknown param: " + i);
                    continue;
                }
            }
        }

        var recorderNode = document.getElementById(Ai.params.id);
        this.volumeBar = document.createElement("canvas");
        recorderNode.appendChild(this.volumeBar);

        this.Recorder = function(source,Ai ,cfg){
            var config = cfg || {};
            var bufferLen = getBufferSize();
            var outputArray = new Int8Array(258);
            //var outputBufferLength = config.outputBufferLength || 4096;
            var compressPath = config.compressPath;
            this.context = source.context;
            this.node = this.context.createScriptProcessor(bufferLen, 1, 1);
            var record_worker = Ai.record_worker;

            var funcSendAudio = null;
            var funcVolume = null;
            var funcVadCheck = null;
            var funcReplayStart = null;
            var funcReplayStop = null;
            var vad_worker = null;
            var encode_worker = null;

            var audio = null;           //audio element

            var inputCount = 0;
            var outputCount = 0;
            //if recording equals false , stop record .
            //if recording equals true , start record .
            var recording = false;      //record state

            var isEnd = false;          //encode state

            function getBufferSize() {
                if (/(Win(dows )?NT 6\.2)/.test(navigator.userAgent)) {
                    return 1024;  //Windows 8
                } else if (/(Win(dows )?NT 6\.1)/.test(navigator.userAgent)) {
                    return 1024;  //Windows 7
                } else if (/(Win(dows )?NT 6\.0)/.test(navigator.userAgent)) {
                    return 2048;  //Windows Vista
                } else if (/Win(dows )?(NT 5\.1|XP)/.test(navigator.userAgent)) {
                    return 4096;  //Windows XP
                } else if (/Mac|PPC/.test(navigator.userAgent)) {
                    return 1024;  //Mac OS X
                } else if (/Linux/.test(navigator.userAgent)) {
                    return 8192;  //Linux
                } else if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    return 2048;  //iOS
                } else {
                    return 16384; //Otherwise
                }
            };

            record_worker.postMessage({
              command: 'init',
              config: {
                compressPath:compressPath,
                sampleRate: this.context.sampleRate,
                outputBufferLength: bufferLen
              }
            });

            this.node.onaudioprocess = function(e){
                if (!recording) return;
                record_worker.postMessage({
                    command: 'record',
                    buffer: e.inputBuffer.getChannelData(0)
                });
            };

            this.configure = function(cfg){
              for (var prop in cfg){
                if (cfg.hasOwnProperty(prop)){
                  config[prop] = cfg[prop];
                }
              }
            };

            this.addCallback = function(func_volume, func_send_audio, func_vad_check, func_replay_start, func_replay_stop){
                funcVolume = func_volume;
                funcSendAudio = func_send_audio;
                funcVadCheck = func_vad_check;
                funcReplayStart = func_replay_start;
                funcReplayStop = func_replay_stop;
            };

            this.startRecord = function(){

                recording = true;
                isEnd = false;

                record_worker.postMessage({command: 'reset'});
                vad_worker = Ai.vad_worker;
                vad_worker.postMessage({command: 'init'});
                vad_worker.onmessage = function(e){
                    if(e.data.type == "debug"){
                        //postMessage({type:"debug", message:e.data.message});
                    } else if(e.data.command == "esvad") {
                        funcVadCheck(e.data.message);
                        //recording = false;
                    //} else if(e.data.command == "volume") {
                        //postMessage({command:"volume", message:e.data.message});
                        //do nothing
                    }
                };

                if(Ai.compress) {
                    encode_worker = Ai.compress;
                    encode_worker.postMessage({command: 'init'});
                    encode_worker.onmessage = function(e){
                        if(e.data.type == "debug"){
                            //postMessage({type:"debug", message:e.data.message});
                        } else if(e.data.command == "encode") {
                            ++outputCount;
                            var buffer = e.data.buffer[0];
                            if(buffer.length >0 ) {                                         //只发送编码后有数据的
                                funcSendAudio(0, buffer);
                            }
                            if(!recording && (outputCount == inputCount)){                  //未录音且编码结束
                                isEnd = true;
                                funcSendAudio(1, null);
                            }
                        }
                    };
                }
            };

            this.stopRecord = function(){
              if (!recording) return;

                recording = false;
                if(!isEnd && (outputCount == inputCount)) {                             //处理停止录音时，编码已完成
                    funcSendAudio(1, null);
                }
                record_worker.postMessage({command: 'exportAudio', type: "wav"});
            };

            this.isRecording = function(){
                return recording;
            };

            this.startReplay = function(){
                if(!audio){
                    throw new Error('no record audio');
                } else {
                    audio.play();
                    funcReplayStart("replay start");
                }

            };

            this.stopReplay = function(){
                if(audio){
                    audio.pause();
                    audio.currentTime = 0;
                    funcReplayStop("replay stop");
                }
            };
            
            record_worker.onmessage = function(e){
                if(e.data.command == "debug"){

                } else if(e.data.command == "blob") {

                    audio = document.createElement('audio');
                    //var url = URL.createObjectURL(e.data.blob);
                    //audio.src = url;
                    window.recordAudio = audio;
                    try {
                        // Fallback if createObjectURL is not supported
                        var fileReader = new FileReader();
                        fileReader.onload = function (event) {
                            audio.src = event.target.result;
                        };
                        //通过暴露recordBuff拿到对应录音Blob文件
                        window.recordBuff = e.data.blob;
                        fileReader.readAsDataURL(e.data.blob);
                    } catch (err) {
                        console.log(err);
                    }

                    audio.type ="audio/wav";
                    audio.loop = false;
                    audio.addEventListener("ended", function()
                    {
                        funcReplayStop("replay stop");
                    },false);

                } else {
                    //return audio data
                    funcVolume(e.data.volume);

                    var buffer = e.data.buffer;
                    var result = new Int16Array(buffer.length);
                    for(var i = 0; i < buffer.length; i++)
                        result[i] = buffer[i];
                    vad_worker.postMessage({
                        command : 'appendData',
                        pcm : result,
                        nSamples : result.length
                    });

                    if(null != encode_worker) {
                        encode_worker.postMessage({
                            command : 'encode',
                            pcm : result
                        });
                        ++inputCount;
                    } else {
                        funcSendAudio(0, result);
                    }
                }

            };

            source.connect(this.node);
            this.node.connect(this.context.destination);
            return this;
            };

/*------------------------------------------------*/


            var Engine=function(Ai){
                console.debug("[ AiRecorderH5 ]: Begin init enigine...");
                this.webSocket = null;

                this.params = null;

                this.wsBuffer = null;

                this.recBuffers = [];
                this.count = 0;

                this.retTimer = null;

                //recorder
                this.audioInput = null,
                this.realAudioInput = null,
                this.inputPoint = null,
                this.analyserNode = null,
                this.audioRecorder = null;
                this.cfg=Ai.params;
                if (!navigator.getUserMedia) {
                    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
                }
                if (!navigator.cancelAnimationFrame) {
                    navigator.cancelAnimationFrame = navigator.webkitCancelAnimationFrame || navigator.mozCancelAnimationFrame;
                }
                if (!navigator.requestAnimationFrame) {
                    navigator.requestAnimationFrame = navigator.webkitRequestAnimationFrame || navigator.mozRequestAnimationFrame;
                }
                if (!window.AudioContext) {
                    window.AudioContext = window.webkitAudioContext || window.mozAudioContext || window.msAudioContext;
                }

                this.audioContext = new window.AudioContext();
                if (!this.audioContext)
                {
                    this.cfg.onError("no audio context!");
                }


                this.gotStream=function (stream) {
                    this.inputPoint = this.audioContext.createGain();
                    this.cfg.onFlashLoad(50000);
                    this.realAudioInput = this.audioContext.createMediaStreamSource(stream);
                    this.audioInput = this.realAudioInput;
                    this.audioInput.connect(this.inputPoint);

                    this.analyserNode = this.audioContext.createAnalyser();
                    this.analyserNode.fftSize = 2048;
                    this.inputPoint.connect(this.analyserNode);
                    this.audioRecorder = new Ai.Recorder(this.inputPoint,Ai);
                    Ai.canRecord = true;
                    this.audioRecorder.addCallback(this.cfg.onVolume, this.sendAudio.bind(this), this.vadCheck, this.cfg.onStartReplay, this.cfg.onStopReplay);

                },


                this.connectWebSocket=function (params)
                {

                    var x=this;
                    var url = ((typeof (params['res']) == "undefined") ? this.cfg['server'] + "/" + params['coreType'] : this.cfg['server'] + "/" + params['coreType'] + "/" + params['res']) + "?e=0&t=0&version=2";
                    console.debug("[ connectWebSocket ]: begin connect to:", url);

                    this.webSocket = new WebSocket(url);

                    Ai.log(1, 19, url, '');

                    this.webSocket.onopen = function (e) {
                        //websocket open event
                        console.debug("[ onopen ]: Connection made to: " + url);
                        var cmdString = JSON.stringify(x.createParams(0, params));
                        //console.log(cmdString);
                        //send cmd connect when websocket open
                        this.send(cmdString);


                        for (var i = 0; i < x.wsBuffer.length; i++) {
                            this.send(x.wsBuffer[i]);
                            //console.log("send : " + i);
                        }
                        x.wsBuffer.length = 0;

                        Ai.log(1, 15, url, '');
                    };
                    this.webSocket.onclose = function () {

                        //websocket close event
                        console.debug("Close connection to websocket");
                        Ai.log(1, 17, url, '');
                    };
                    this.webSocket.onmessage = function (e) {
                        clearTimeout(x.retTimer);
                        console.debug("[ onmessage ]", e.data);
                        //websocket message
                        var json = JSON.parse(e.data);
                        if (json.hasOwnProperty("error")) {
                            x.stopRecord(true);
                            var errMes = "error: " + json['error'];
                            x.cfg.onError(errMes);
                        } else {
                          if (json.result.hasOwnProperty("snt")) {
                            x.cfg.onInternalScore(0, json);
                          } else {
                            Ai.dictResults[json.tokenId] = json;
                            x.cfg.onGetResult(json);
                          }
                        }
                    };
                    this.webSocket.onerror = function (e) {
                        //websocket error
                        if (typeof stopRecord == 'function')
                          stopRecord(true);
                        x.cfg.onError(e.data);
                        Ai.log(1, 16, url, e.data);
                    };
                },

                this.disconnectWebSocket=function ()
                {
                    this.webSocket.close();
                },

                this.changeCoreType=function (params)
                {
                    this.disconnectWebSocket();
                    this.connectWebSocket(params);
                },

                this.createParams=function (flag, params_obj)
                {
                    var timestamp = params_obj['timestamp'];
                    var sig = params_obj['sig'];
                    var eParams = null;
                    if (0 == flag) {			//connect
                        eParams = {
                            sdk: {
                                version: 0x01000000,
                                source: 0x04,
                                protocol: 'websocket'
                            },
                            app: {
                                applicationId: this.cfg['appKey'],
                                sig: sig,
                                alg: this.cfg['alg'],
                                timestamp: timestamp,
                                userId: this.cfg['userId']
                            }};

                    } else {
                        eParams = {
                            tokenId: this.createUUID(), //客户端请求token
                            audio: {//音频信息
                                "audioType": this.cfg['encode'] == "raw" ? "wav" : "spx", //格式
                                "channel": 1, //通道
                                "sampleBytes": 2, //采样字节
                                "sampleRate": 16000		//采样率
                            },
                            request: params_obj
                            /*
                            request: {//内核请求参数
                                "coreType": params_obj['coreType'],
                                "rank": params_obj['rank'] | 100,
                                "refText": params_obj['refText']
                            }
                            */
                        };

                        if (typeof (params_obj['precision']) != "undefined") {
                            eParams['request']['precision'] = params_obj['precision'];
                        }

                        Ai.params.onRecordIdGenerated(0, {recordId : eParams.tokenId });
                    }
                    return eParams;
                },
                /**
                 * start WebSocket and recorder
                 * varible : params_obj, object for start.
                 */
                this.startRecord=function (params_obj)
                {
                  console.debug("[ startRecord ]: ", params_obj);

                    if (this.audioRecorder.isRecording()) {
                        this.cfg.onError("please wait last record end!");
                        return;
                    }
                    this.wsBuffer = [];
                    if (null == this.params) {			//第一次
                        this.params = params_obj;
                        this.connectWebSocket(params_obj);
                    } else {
                        if (this.params['coreType'] != params_obj['coreType']) {		//发生内核切换
                            this.params = params_obj;
                            this.changeCoreType(params_obj);
                        } else {
                            if (this.webSocket.readyState != WebSocket.OPEN) {
                                this.params = params_obj;
                                this.connectWebSocket(params_obj);								//未切换但网络已断开，则重连
                            }
                        }
                    }

                    if (this.audioRecorder == null)
                    {
                        this.cfg.onError("no input device!");
                        return;
                    }

                    var startCmd = JSON.stringify(this.createParams(1, params_obj));

                    if (this.webSocket.readyState == WebSocket.OPEN) {
                        this.webSocket.send(startCmd);					//如果已连接则直接发送start
                    } else {
                        this.wsBuffer.push(startCmd);					//如果未连接则缓存start
                    }


                    this.recBuffers = [];
                    if (typeof (params_obj['waringTone']) != "undefined" && params_obj['waringTone'] == true) {
                        var audio = document.createElement('audio');
                        var x = this;
                        var promises = null;
                        audio.src = recordMedia;
                        audio.type = "audio/mpeg";
                        audio.loop = false;
                        audio.volume = 0.5;
                        audio.play();
                        audio.addEventListener('ended', function () {
                           x.enterRecord();
                        })
                    } else {
                        this.enterRecord();
                    }
                },

                this.enterRecord=function ()
                {
                    this.audioRecorder.startRecord();
                    Ai.params.onStart();
                },


                /**
                 * stop record
                 * varible : wait_time, call getresult function after wait_time.
                 * varible : hasErr, when an error is encountered and needs to stop record, please set it true
                 */
                this.stopRecord=function (hasErr)
                {
                    //console.debug("[ stopRecord ] hasErr: " + hasErr);

                    if (this.audioRecorder.isRecording()) {
                        this.audioRecorder.stopRecord();
                        if (!hasErr) {				//正常停止
                            var x=this;
                            this.retTimer = setTimeout(function(){x.onTimeout()}, this.cfg.coreTimeout);
                        }

                        Ai.params.onStop();
                      }
                },

                this.startReplay=function ()
                {
                    this.audioRecorder.startReplay();
                },


                this.stopReplay=function ()
                {
                    this.audioRecorder.stopReplay();
                },
                /**
                 * send audio data
                 * varible : state, 0 feed, 1 end
                 * varible : data, audio pcm( pcm , Uint8Array)
                 */
                this.sendAudio=function (state, data)
                {
                    this.count++;
                    if (1 != state) {
                        this.recBuffers.push(data);//
                    }
                    if (1 == state || 6 ==  this.count) {
                        if (this.recBuffers.length > 0) {									//只有this.recBuffers有内容才发生数据
                            var output = this.recBuffers.splice(0, this.recBuffers.length);
                            var i;
                            var outputArray;
                            if (this.cfg['encode'] != "raw") {
                                outputArray = new Uint8Array(output.length * 70);
                                for (i = 0; i < output.length; i++) {
                                    outputArray.set(output[i], i * 70);
                                }
                            } else {
                                outputArray = new Int16Array(output.length * 320);
                                for (i = 0; i < output.length; i++) {
                                    outputArray.set(output[i], i * 320);
                                }
                            }
                            if (this.webSocket.readyState == WebSocket.OPEN) {
                                this.webSocket.send(outputArray.buffer);					//如果已连接则直接发送audio
                            } else {
                                this.wsBuffer.push(outputArray.buffer);					//如果未连接则缓存audio
                            }
                        }
                        this.count = 0;
                        if (state == 1) {
                            if (this.webSocket.readyState == WebSocket.OPEN) {
                                this.webSocket.send(new ArrayBuffer(0));
                            } else {
                                this.wsBuffer.push(new ArrayBuffer(0));
                            }

                        }
                    }

                },

                this.vadCheck=function (state) {
                    console.debug('[ vadCheck ]: detect record stop, but ignore it now...');
                    /*
                    if (state == 'end') {
                        Ai.engine.stopRecord();
                    }
                    */
                },

                this.onTimeout=function ()
                {
                    this.cfg.onError("评分超时");
                },

                this.createUUID =(function (uuidRegEx, uuidReplacer) {
                    return function () {
                        return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
                    };
                })(/[xy]/g, function (c) {
                    var r = Math.random() * 16 | 0,
                            v = c == "x" ? r : (r & 3 | 8);
                    return v.toString(16);
                })
                navigator.getUserMedia({audio: true}, this.gotStream.bind(this), function (e) {
                  console.error("no audio deivce");
                    Ai.params.onError("no audio device!");
                });
            }


        this.record = function (params_obj) {
            var time = Math.floor(new Date().getTime() / 1000);
            if(typeof this.params['sig']!=='undefined'){
                params_obj.sig=this.params.sig,params_obj.timestamp=this.params.timestamp;
            }
            if (params_obj.sig !== '' && params_obj.timestamp !== undefined && parseInt(params_obj.timestamp) >= time - TIME_OUT) {
              if(typeof params_obj['onRecordIdGenerated']!=='undefined'){
                Ai.params.onRecordIdGenerated = params_obj['onRecordIdGenerated'];
              }

              if(typeof params_obj['onStart']!=='undefined'){
                Ai.params.onStart = params_obj['onStart'];
              }

              if(typeof params_obj['onStop']!=='undefined'){
                Ai.params.onStop = params_obj['onStop'];
              }

              if(typeof params_obj['onInternalScore']!=='undefined'){
                Ai.params.onInternalScore = params_obj['onInternalScore'];
              }

              if(typeof params_obj['duration']!=='undefined') {
                Ai.__durationTimer = setTimeout(this.stop, params_obj['duration']);
              }

              var serverParam = params_obj.serverParams;

              serverParam.sig = params_obj.sig;
              serverParam.timestamp = params_obj.timestamp;

              this.engine.startRecord(serverParam);
            } else {
                this.getSig(this.record, params_obj);
            }
        };

        this.stop = function ()
        {
            Ai.engine.stopRecord();

            if (Ai.__durationTimer) {
              clearTimeout(Ai.__durationTimer);
              Ai.__durationTimer = null;
            }
        };

        this.startReplay = function (options)
        {
            if(typeof options['onStop']!=='undefined'){
              Ai.__onStopReplay = options['onStop'];
            }

            this.engine.startReplay();
        };

        this.stopReplay = function ()
        {
            this.engine.stopReplay();
        };

        this.reset = function() { this.engine.stopReplay();this.engine.stopRecord(); };
        
        var _delayTimes = 0;
        var _scoreOptions = null;

        var _getScore = function() {
          if (_scoreOptions != null) {
            if (Ai.dictResults.hasOwnProperty(_scoreOptions.recordId)) {
              _scoreOptions.success(Ai.dictResults);
              delete [_scoreOptions.recordId];
              _delayTimes = 0;
              _scoreOptions = null;
            } else {
              _delayTimes++;
              if (_delayTimes > 300) {
                _scoreOptions.success("无此评分结果。 recordId:" + _scoreOptions.recordId);
                _delayTimes = 0;
                _scoreOptions = null;
              } else {
                setTimeout(_getScore, 100);
              }
            }
          }
        };

        this.getScores = function(options) {
          _scoreOptions = options;
          _getScore();
        }

        var shown = false;
        this.showVolumeBar = function(options, setView) {
          if (shown) return;
          shown = true;

          var mic;
          var analyser;
          var audioCtx;
          var cv = Ai.volumeBar;
          cv.width = recorderNode.width > 0 ? recorderNode.width : 170;
          cv.height = recorderNode.height > 0 ? recorderNode.height : 50;

          var ctx  = cv.getContext('2d');
          var W    = cv.width;
          var H    = cv.height;
          var STEP = 1;
          var N    = W / STEP;

          var energies = new Array();

          cv.border = 1;
          cv.style.backgroundColor = "#CBCBCB";


          //var skip = 10;
          function draw() {
            /*
            if (skip < 10) {
              skip = skip + 1;
              requestAnimationFrame(draw);
              return;
            }
            skip = 0;
            */

            ctx.clearRect(0, 0, W, H);
      
            ctx.beginPath();
            ctx.moveTo(0.5, Math.floor(H * 0.9) + 0.5);
            ctx.lineTo(W - 0.5, Math.floor(H * 0.9) + 0.5);
            ctx.closePath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
            ctx.stroke();
      
            ctx.strokeStyle = "#6CA6CD";
            var dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
      
            for (var i = 0; i < analyser.frequencyBinCount; i += analyser.frequencyBinCount / 3) {
              if (energies.length >= N) energies.shift();
              energies.push(dataArray[i]);
            }
      
            ctx.beginPath();
            for (var j = 0; j < N; j++) {
              var energy = energies[j] * 1.2;
              ctx.moveTo(STEP * j, H);
              ctx.lineTo(STEP * j, H - H * energy / 256);
              ctx.stroke();
            }
      
            //requestAnimationFrame(draw);
            setTimeout(draw, 150);
          }
          
          navigator.getMedia( { audio:true }, function(stream) {
              Ai.vAudioCtx = audioCtx = new (window.AudioContext || window.webkitAudioContext);
              mic = audioCtx.createMediaStreamSource(stream);
              analyser = audioCtx.createAnalyser();
          
              analyser.fftSize = 2048;
              mic.connect(analyser);

              ctx.strokeStyle = "#6CA6CD";
                   
              draw();
          }, function(){} );
        }

        var testWebSocket = function() {
          if (Ai.params.hasOwnProperty("onConnectorStatusChange") && typeof Ai.params.onConnectorStatusChange == "function") {
              Ai.params.onConnectorStatusChange(50109, 0);
          }

          try {
            var webSocket = new WebSocket(Ai.params.server + "/en.sent.score");
          } catch (err) {
            if (Ai.params.hasOwnProperty("onConnectorStatusChange") && typeof Ai.params.onConnectorStatusChange == "function") {
              Ai.params.onConnectorStatusChange(50101, 0);
            }
            console.error("[ testWebSocket ]connect failed to: " + Ai.params.server);

            return;
          }

          webSocket.onopen = function (e) {
            if (Ai.params.hasOwnProperty("onConnectorStatusChange") && typeof Ai.params.onConnectorStatusChange == "function") {
              Ai.params.onConnectorStatusChange(50100, 0);
            }


            webSocket.close();
            webSocket = null;
          };

          webSocket.onerror = function (e) {
            if (Ai.params.hasOwnProperty("onConnectorStatusChange") && typeof Ai.params.onConnectorStatusChange == "function") {
              Ai.params.onConnectorStatusChange(50101, 0);
            }
            console.error("[ testWebSocket ]connect failed to: " + Ai.params.server);

            webSocket = null;
          };
        }

        testWebSocket();

        this.log = function(evtid, statusid, serverurl, reason) {
          var url = LOGSERVER + "?eid=" + evtid + "&est=" + statusid + "&applicationId=" + Ai.params.appKey + "&uid=" + Ai.params.userId;
          var params = {
              body: {
                conn_url: encodeURIComponent(serverurl), 
                reason: reason, 
                user_agent: navigator.userAgent, 
                prot: 1
              }
          };
          var xmlreq = new XMLHttpRequest();

          xmlreq.open('POST', url, true);
          xmlreq.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
          xmlreq.send('log=' + JSON.stringify(params));
        }

        this.getSig = function (callback, params) {
            if (this.params['sigurl'] == '') {
                Ai.params.onError('sigurl not set!');
                return false;
            }
            else {
              var that=this;
              ai$.ajax({
                url:this.params['sigurl'],
                type:'GET',
                data:{alg:this.params['alg']},
                dataType:'json',
                success:function(data){
                  that.params['timestamp'] = data.timestamp;
                  that.params['sig'] = data.sig;
                  if (callback !== undefined) {
                    callback.call(that,params);
                  }
                },
                error:function(data){
                },
                beforeSend:function(request){
                  request.setRequestHeader('Authorization', cookie.get("Authorization").replace(/\"/g, ''));
                }
            })
            }
        }
    };

  return function(options) {
    var _recorder;

    if (!(options['sigurl']) || !(typeof options['sigurl'] == 'string') ||(options['sigurl'].length <= 0)) {
      if (typeof options["onError"] !== 'undefined') {
        options["onError"]("sigurl参数设置不对。当前sigurl：" + options['sigurl']);
      }
      console.error("sigurl参数设置不对。当前sigurl：" + options['sigurl']);

      return null;
    }

    switch(options.mode) {
      case chivox.MODE.HTML5:
        _recorder = new AiRecorderH5(options);
        break;
      default:
        _recorder = new chivox.AiRecorderAs(options);
        break;
    }
    _recorder.mode = options.mode;
    return _recorder;
  };
})();
