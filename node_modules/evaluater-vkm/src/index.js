/*
 * 评测组件集成版
 *
 * 组件包含了录音和评测两个主要的功能
 */
var states = require('./states')
var filepush = require('fe-filepush').default

var EvaluaterCore = require('evaluater-core-vkm')
var AudioRecorder = require('audio-recorder-vkm')
var coreStates = {
  NOT_READY: 1,
  CONNECTING: 2,
  PREPARE_START: 3,
  WAITING_AUDIO_STREAM: 4,
  RESULT_RECEIVING: 5,
  RESULT_RECEIVED: 6,
  CLOSED: 7
}

function VKEvaluater(options) {
  var env = options.env
  apiUrlMap = {
    test: 'https://a66-ecp.vipkid-qa.com.cn/iscp/api/v1',
    pre: 'https://pre-ecp.vipkid.com.cn/iscp/api/v1',
    prod: 'https://wss.vipkid.com.cn/iscp/api/v1'
  }

  var appId = options.appId
  var _errorCb = options.onError
  var _stateCb = options.onState
  var _audioUploadingList = []
  var _audioUploadedList = []
  var _resultList = []
  // 音频数据上传的标识，为减少对业务端的影响，目前是队列上传，即每次只有一个音频在上传。
  var _audioUploading = false
  // 评测结果是否仍在处理中的标识
  // 主要用于结果中无audioUrl的情况，需要有上传到cdn的等待过程
  var _resultDealing = false
  var _currId = null
  var _currAudioBlob = null
  var apiUrl = apiUrlMap[env || 'prod']

  // TODO 检查初始化参数

  // this.init = init
  this.start = start
  this.stop = stop
  this.close = close
  this.state = states.NOT_READY

  var that = this

  var evaluater
  that.recorder = new AudioRecorder()

  // 自动执行初始化操作
  init()

  // 初始化
  function init() {
    // 初始化录音组件
    that.recorder.init(function(err) {
      if(err) {
        _throwError(err, {recorder: true})
      } else {
        // 初始化评测核心组件
        evaluater = new EvaluaterCore({
          appId: appId,
          env: env,
          onState: _evaluaterStateChange,
          onError: _evaluaterError,
        })
      }
    })

    // 绑定录音回调函数
    that.recorder.onRecording(function(stream) {
      if(!_checkCondition('sendAudioStream')) return

      evaluater.sendAudioStream(stream)
    })
    that.recorder.exportBlob(function(blob) {
      _currAudioBlob = blob
      _audioUploadingList.push({ id: _currId, audioBlob: blob })
      _startAudioUpload()
    })
  }

  // 开始评测
  function start(info) {
    if(!_checkCondition('start')) return

    // 发送评测文本信息
    evaluater.sendAudioInfo(info)

    // 开始录音
    that.recorder.start()
    // _updateState(states.START_AUDIO_RECORD)
    _updateAndEmitState(states.AUDIO_RECORDING)

    // TODO 增加录音超时判断
    // Tip: 使用timeout
  }

  function stop() {
    if(!_checkCondition('stop')) return

    _currId = _generateUniqStr(16)

    // 停止录音
    that.recorder.stop()
    evaluater.stop()
  }

  function close() {
    if(that.state === states.NOT_READY || that.state === states.CLOSED) return
    // 停止录音
    that.recorder.stop()
    evaluater.close()
  }

  function _evaluaterStateChange(newState) {
    _log('*** EvaluaterCore state change:', newState)

    switch(newState.code) {
      case coreStates.NOT_READY:
        _updateState(states.NOT_READY)
        break
      case coreStates.CONNECTING:
        _updateAndEmitState(states.CONNECTING)
        break
      case coreStates.PREPARE_START:
        if(!_resultDealing) {
          _updateAndEmitState(states.PREPARE_START)
        }
        break
      case coreStates.RESULT_RECEIVING:
        _updateAndEmitState(states.RESULT_RECEIVING)
        break
      case coreStates.RESULT_RECEIVED:
        var data = newState.data
        var result = data.view
        result.audioBlob = _currAudioBlob
        // 评测结果中包含audioUrl，说明第三方返回了audioUrl，直接将结果返回给客户端
        if(result.audioUrl) {
          _updateAndEmitState(states.RESULT_RECEIVED, null, result)
          evaluater.updateState(states.PREPARE_START);
        } else {
          _resultDealing = true
        }
        // 评测结果中无audioUrl，需要sdk先将audio上传至cdn，然后和结果一并返回给业务端
        _resultList.push({ id: _currId, result: result, scoreId: data.scoreId })
        _dealResult(_currId)
        break
      case coreStates.CLOSED:
        _updateAndEmitState(states.CLOSED)
        break
    }
  }

  // 处理评测结果，主要在评测结果返回后，或者音频上传结束后触发
  function _dealResult(id) {
    var resultItem = find(_resultList, { id: id })
    var audioItem = find(_audioUploadedList, { id: id })

    if(!resultItem || !audioItem) return

    var result = resultItem.result
    // 处理评测结果中无第三方audioUrl的情况
    // 即使用cdn的url代表第三方audioUrl，然后将结果返回给客户端
    if(!result.audioUrl) {
      result.audioUrl = audioItem.audioUrl
      _updateAndEmitState(states.RESULT_RECEIVED, null, result)
      
      _resultDealing = false;
      evaluater.updateState(states.PREPARE_START);
    }

    // 上报评测结果
    var uploadResultInfo = { scoreId: resultItem.scoreId, audioUrl: audioItem.audioUrl }
    _uploadEvaluateResult(uploadResultInfo, function() {})

    // 清除已处理项
    _resultList.splice(_resultList.indexOf(resultItem), 1)
    _audioUploadedList.splice(_audioUploadedList.indexOf(audioItem), 1)
  }

  function _evaluaterError(err) {
    _log('EvaluaterCore error:', err)

    switch(err.code) {
      case 1101:
      case 1104:
      case 1105:
        _throwError(err, {recorder: true})

        if([1104, 1105].indexOf(err.code) > -1) {
          _uploadError(err)
        }
        break
      case 1107:
        _throwError(err, {recorder: true})
        break
      case 4001:
      case 4002:
      case 4003:
        that.recorder.stop()
        _throwError(err, {evaluater: true})
        break
      default:
        _throwError(err, {recorder: true})
        _log('evaluater core error: ', err)

      // TODO 增加更多地错误判断，比如文本参数错误
    }
  }

  function _checkCondition(stage) {
    _log('stage: ', stage, ', state: ', that.state)

    // 首先，检测init状态
    if(that.state === states.NOT_READY) {
      throw new Error('[VKEvaluater] The server not ready.')
    }
    if(that.state === states.CONNECTING) {
      throw new Error('[VKEvaluater] The server still in connecting.')
    }
    // if(that.state === states.CANCELING) {
    //   throw new Error('[VKEvaluaterCore] In canceling, please waiting for cancel finished.')
    // }
    if(that.state === states.CLOSED) {
      throw new Error('[VKEvaluaterCore] The server already closed. Please re-init it before use it agiain.')
    }

    if(stage === 'start' && that.state !== states.PREPARE_START) {
      throw new Error('[VKEvaluater] Start must be called after evaluater prepared.')
    }
    if(stage === 'stop' && that.state !== states.AUDIO_RECORDING) {
      console.warn('[VKEvaluater] Stop must be called after evaluater.start().')
      return false
    }

    return true
  }

  function _throwError(type, options) {
    var recorderErrMap = {
      902001: 'recordNotSupport',
    }

    var evaluaterErrMap = {
      1101: 'evaluateNotSupport',
      1104: 'cannotConnect',
      1105: 'connectTimeout',
      1107: 'authFial',
      4001: 'audioInfoInvalid',
      4002: 'evaluateFail',
      4003: 'evaluateTimeout',
      1000: 'unknown'
    }

    var message = options && options.message

    // 将audioRecorder的error转换成自身的error
    if(options && options.recorder === true) {
      message = type.message
      type = recorderErrMap[type.code]
    }
    // 将evaluater的error转换成自身的error
    if(options && options.evaluater === true) {
      message = type.message
      type = evaluaterErrMap[type.code]
    }

    var map = {
      'evaluateNotSupport': { code: 1101, message: message || 'evaluate not supported' },
      'recordNotSupport': { code: 1102, message: message || 'record not supported' },
      'recordPermissionDeny': { code: 1103, message: message || 'record permission deny' },
      'cannotConnect': { code: 1104, message: 'server cannot connect' },
      'connectTimeout': { code: 1105, message: 'connect timeout' },
      'networkAnomaly': { code: 1106, message: 'network anomaly' },
      'authFial': { code: 1107, message: 'appId invalid' },

      /* 其他异常错误 */
      'audioInfoInvalid': { code: 4001, message: message || 'audio info invalid' },
      'evaluateFail': { code: 4002, message: message || 'evaluate failed' },
      'evaluateTimeout': { code: 4003, message: message || 'evaluate timeout' },
      'unknown': { code: 1000, message: 'unknown error' },
    }

    var err = map[type]
    if(err) err.message = message || err.message

    _errorCb(err || map.unknown)
  }

  function _updateState(newState) {
    that.state = newState
  }

  function _updateAndEmitState(newState, message, data) {
    _updateState(newState)

    _stateCb({code: newState, message: message, data: data})
  }

  // 上传音频文件至CDN
  function _uploadAudio(audioBlob, cb) {
    // 忽略本地测试环境
    if(location.hostname === 'localhost') {
      _log('localhost环境下，上传CDN会涉及跨域，所以跳过上传')
      return cb(null, 'https://media.vipkidstatic.com/speechcloud/audio/3fccefb4632daaf9.wav')
    }

    var filename = _generateUniqStr(16)
    var file = new File([audioBlob], filename + '.wav', {type: 'audio/wav', lastModified: Date.now()})

    var upload = new filepush({
      accessKey: '8572e0430fce035c',
      secretKey: '07c84c233bee4e23bac60b38b4cc675a',
      client: 'speechcloud',
      path: 'speechcloud/audio/'
    })

    upload.addfiles(file)
    upload.submit(function(err, data) {
      if(err) {
        cb(err)
      } else {
        cb(null, data.objects[0].url)
      }
    }, function() {
      // _log(file, progressEvent)
    })
  }

  function _startAudioUpload() {
    if(_audioUploading) return

    if(_audioUploadingList.length === 0) return

    _audioUploading = true

    var once = function() {
      item = _audioUploadingList.shift()

      // 已无待上传音频
      if(!item) {
        _audioUploading = false
        return
      }

      _uploadAudio(item.audioBlob, function(err, audioUrl) {
        if(err) _log('upload audio fail', err)

        item.audioUrl = audioUrl || null
        _audioUploadedList.push(item)
        _dealResult(item.id)

        once()
      })
    }

    once()
  }

  // 上报请求及结果信息
  function _uploadEvaluateResult(item, cb) {
    _myAjax({
      url: apiUrl + '/result/save',
      type: 'post',
      data: {
        userId: options.userId || '', //新增 用来获取用户数据
        appId: appId,
        scoreId: item.scoreId,
        audioUrl: item.audioUrl,
        deviceInfo: JSON.stringify(_getDeviceInfo())
      },
      success: function() {
        cb && cb()
        _log('upload evaluate result success')
      },
      error: function(err) {
        cb && cb()
        _log('send evaluate result fail: ', err)
      }
    })
  }

  // 上报错误信息
  function _uploadError(err) {
    _myAjax({
      url: apiUrl + '/abnormal/report',
      type: 'post',
      data: {
        appId: appId,
        code: '50001',
        description: JSON.stringify({
          userId: options.userId || '', //新增 用来获取用户数据
          message: err.message,
          time: new Date().getTime(),
          // TODO add device info
          deviceInfo: JSON.stringify(_getDeviceInfo()),
          serverVersion: 'v2'
        })
      },
      success: function() {
        _log('upload error success')
      },
      error: function(err) {
        _log('upload error fail: ', err)
      }
    })
  }

  function _myAjax(settings) {
    settings.success = settings.success || function() {}
    settings.error = settings.error || function() {}

    var xhr = new XMLHttpRequest();
    var hasError = false

    xhr.onerror = function(err) {
      _log('xhr err:', err)
      hasError = true
    }

    xhr.onloadend = function() {
      if(hasError) {
        settings.error('cannot connect server')
      } else {
        // deal unexpected error
        if(xhr.status === 404) {
          settings.error('server error(404 not found)')
          return
        }

        // deal JSON.parse error
        var res
        try {
          res = JSON.parse(xhr.responseText)
        } catch (e) {
          return settings.error('response format error');
        }

        if(xhr.status === 200) {
          settings.success(res.data);
        } else if(xhr.status === 400) {
          settings.error(res.message);
        }
      }
    }

    xhr.open(settings.type || 'get', settings.url, true);

    if(settings.type === 'post' && settings.data) {
      xhr.setRequestHeader("Content-Type","application/json; charset=utf-8");
      xhr.send(JSON.stringify(settings.data));
    } else {
      xhr.send();
    }
  }

  function _getDeviceInfo() {
    return {
      userAgent: navigator.userAgent,
      vendor: navigator.vendor,
      platform: navigator.platform,
      appName: navigator.appName
    }
  }

  function _generateUniqStr(length) {
    var str = ''
    length = length || 32
    while (length--) {
      str += (Math.random() * 16 | 0) % 2 ? (Math.random() * 16 | 0).toString(16)
        : (Math.random() * 16 | 0).toString(16).toUpperCase()
    }
    return str.toLowerCase()
  }

  function _log() {
    if(!((window._vkm_debug === true) || (window._vkm_evaluate_debug === true))) return

    var args = Array.prototype.slice.call(arguments)
    // args.unshift(new Date().toLocaleString())
    args.unshift('Evaluater:')
    console.debug.apply(console, args)
  }

  function find(arr, params) {
    var keys = Object.keys(params)
    for(var i=0; i<arr.length; i++) {
      var item = arr[i]
      var allMatch = true
      for(var j=0; j<keys.length; j++) {
        var key = keys[j]
        if(item[key] !== params[key]) {
          allMatch = false
          break
        }
      }
      if(allMatch) {
        return item
      }
    }

    return null
  }
}

if(window) window.VKEvaluater = VKEvaluater
module.exports = VKEvaluater
