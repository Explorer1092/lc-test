/**
 *  @file: request.js is a <js> file
 *  @date: File created 2018-06-26 10:46
 *  @author:  shangwenhe
 */

'use strict';

import axios from 'axios';
import crypto from './crypto.fe.js';
import uuidv4 from './sbin/uuid-v4.js';
import VOSSDK from './melt/vos.sdk';
import Promise from 'promise';
import asyncFilterLimit from 'async/filterLimit'

class request extends crypto {
  constructor({accessKey, secretKey, client= 'filepush fe-sdk', path}){
    super();
    Object.assign(this,{accessKey, secretKey, client, path})
  }
  // 创建一个新的HTTP实例
  http(headers = {}){
    let timestamp = Math.round(new Date().getTime() / 1000).toString();
    return axios.create({
      baseURL: 'https://fe-vos.vipkid.com.cn/rest/',
      timeout: 6000,
      headers: Object.assign({
        'Content-Type': 'application/json',
        'VOS-ACCESS-KEY': this.accessKey,
        'VOS-ACCESS-SIGN': this.UrlSafeEncode(this.HmacSHA256(timestamp + '.' + this.accessKey, this.secretKey)),
        'VOS-ACCESS-TIMESTAMP': timestamp,
        'X-VOS-CLIENT': this.client 
      }, headers)
    })
  }
 
  // 取得文件密钥
  async getToken(keys,header={}){
    let axios = this.http();
    return new Promise((resolve, reject)=>{
      axios.post('/v1/object/put/token/', {
        "requestToken": this.requestToken({
          header,
          payload: {
            "requestId": uuidv4,
            "client": this.client,
            "clouds": ['kodo', 'oss']
          },
          secretKey: this.secretKey
        }),
        keys,
      }).then((res)=>{
        resolve([null, res.data])
      }).catch((err)=>{
        resolve([err])
      })
    })
  } 

  // 上传文件 
  async uploadFile(token, process){
    if(!token.accessToken){
      throw new Error('token 结果出错, 不存在在accessToken'); 
      return;
    }
    let [ tmp1, accessToken, tmp2, tmp3 ] = this.parseToken(token.accessToken)
    let vos = new VOSSDK(accessToken)
    return new Promise((resolve, reject)=>{
      vos.put(this.files, (err, data) => {
        resolve([err, data]);
      }, process);
    })
  }

  // 通知服务器已经上传成功
  async notifier(keys, accessToken){
    let axios = this.http();
    return new Promise((resolve, reject)=>{
      axios.post('/v1/object/put/commit', {
        accessToken,
        keys,
      }).then((res)=>{
        resolve([null, res.data])
      }).catch((err)=>{
        resolve([err])
      })
    })
  }
  
  // 通知服务器已经上传成功
  async exists(keys){
    let axios = this.http();
    return new Promise((resolve, reject)=>{
			/**
			* @desc 并发验证文件是否存在
			*/
			asyncFilterLimit(keys, 1, (key, callback) => {
				axios.post('/v1/object/exists', {key}).then(({data}) => {
					if (data && data.exists) {
						callback(Object.assign({key}, data));
						return;
					}
					callback(null, data);
				}).catch(function(err) {
					/**
					* @desc 如果请求出错则跳过该上传文件
					*/
					callback(err);
				})
			}, (err, files) => {
				resolve([err, files]);
			})
    })
  }

}

export default request;
