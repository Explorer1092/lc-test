let routerRecord = ['/']
let locatRouterRecord = localStorage.getItem('routerRecord')
if(locatRouterRecord){
  routerRecord = JSON.parse(locatRouterRecord)
}

/**
 * !!!! 目前只考虑了  path  没有考虑search部分（带问号的）
 *
 *
 *  例： ['/',A,B,C,D,E,F]
 *
 * 1. 进入根目录 '/', 重置 routerRecord = ['/']
 * 2. 进入path = E , 相当于 回退 ,所以 routerRecord.pop()
 * 3. 进入path = F , routerRecord 不做改动
 * 4. 进入 C -> D -> E -> F, 相当于 CDEF 重复， routerRecord 会退到 ['/',A,B,C,D,E,F]
 * 5. 
 * 6. 
 * 7. 如果业务需求path = Z  不存入 routerRecord,  可以调用VK.replace()  , 相当于 Z替换F , routerRecord 变为['/',A,B,C,D,E,Z]
 *  
 */

const _push = (path) => {
  if(routerRecord.length > 1){
    //倒数第二项
    const last2 = routerRecord[routerRecord.length -2]
    if(last2 === path){
      routerRecord.pop()
    }
  }

  if(path === '/' || routerRecord.length === 0){
    routerRecord = ['/']
  }else{
    routerRecord.push(path)
    delLoop(routerRecord)
  }
  localStorage.setItem("routerRecord", JSON.stringify(routerRecord))
}

/**
 *   [ 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 ]
 *   
 *   num(每次比较的个数,) = 1   <=  halfLen(循环多少次--层数 )
 *                       1 | 2
 *                     1 2 | 3 4
 *                   1 2 3 | 4 5 6
 *                 1 2 3 4 | 5 6 7 8
 *               1 2 3 4 5 | 6 7 8 9 10
 *              
 */

function delLoop (arr){
  const len = arr.length
  //需要比较的次数
  let halfLen = Math.floor( len / 2 )
  //每次比较的个数
  let num = 1

  while(num <= halfLen){
    let isSame = simpleSame(arr, num, len)

    if( isSame ){
      let i = 1
      while( i <= num ){
        arr.pop()
        i++
      }
      break
    }
    num++
  }
}

function simpleSame(arr, num, len){
  for(let i = 1; i <= num; i++){
    if(arr[len-i] !== arr[len - i - num]){
      return false
    }
  }
  return true
}

export {
  routerRecord,
  _push
}
